use std::fs;
use std::io;
use std::env;
use deku::prelude::*;
use deku::DekuWrite;
use wwise_format::HIRCObject;

use pretty_assertions::assert_eq;

fn main() {
    let args: Vec<String> = env::args().collect();
    let paths = &args[1..];

    test();
    panic!("DIE DIE DIE");

    for path in paths {
        let mut handle = fs::File::open(path)
            .expect("Could not acquire file handle");

        println!("Checking {}", path);
        dissect_bnk(&mut handle)
            .expect("Could not read file for parsing");
    }
}

fn test() {
    let buffer : [u8; 708] = [
        0x0F, 0xBF, 0x02, 0x00, 0x00, 0x74, 0x6A, 0x8C, 0x4E, 0x64, 0x03, 0x00, 0x00, 0x00, 0x52, 0x35,
        0x5B, 0x24, 0xDE, 0xB7, 0xB0, 0xF9, 0x11, 0x52, 0x0F, 0x79, 0x00, 0x00, 0x00, 0xA0, 0x02, 0x00,
        0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x05, 0x00, 0x32, 0x00, 0x64, 0x00, 0x57, 0xCA,
        0xBC, 0x26, 0x06, 0x00, 0x05, 0x00, 0x32, 0x00, 0x64, 0x00, 0x6B, 0xA2, 0x80, 0x51, 0x10, 0x00,
        0x05, 0x00, 0x32, 0x00, 0x64, 0x00, 0x69, 0xAB, 0xCC, 0x6D, 0x1A, 0x00, 0x05, 0x00, 0x32, 0x00,
        0x64, 0x00, 0x24, 0xD8, 0xB8, 0xBA, 0x24, 0x00, 0x05, 0x00, 0x32, 0x00, 0x64, 0x00, 0x3D, 0x90,
        0x78, 0xF7, 0x2E, 0x00, 0x05, 0x00, 0x32, 0x00, 0x64, 0x00, 0x57, 0xCA, 0xBC, 0x26, 0x0B, 0x00,
        0x01, 0x00, 0x32, 0x00, 0x64, 0x00, 0x6B, 0xA2, 0x80, 0x51, 0x0C, 0x00, 0x01, 0x00, 0x32, 0x00,
        0x64, 0x00, 0x69, 0xAB, 0xCC, 0x6D, 0x0D, 0x00, 0x01, 0x00, 0x32, 0x00, 0x64, 0x00, 0x24, 0xD8,
        0xB8, 0xBA, 0x0E, 0x00, 0x01, 0x00, 0x32, 0x00, 0x64, 0x00, 0x3D, 0x90, 0x78, 0xF7, 0x0F, 0x00,
        0x01, 0x00, 0x32, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x82, 0x83, 0x68, 0x0A, 0x32, 0x00,
        0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB8, 0xAD, 0xCA, 0x17, 0x32, 0x00, 0x64, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x18, 0x18, 0xDF, 0x3F, 0x32, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0xB4,
        0x86, 0x26, 0x32, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1A, 0xBD, 0xD4, 0x3E, 0x32, 0x00,
        0x64, 0x00, 0x57, 0xCA, 0xBC, 0x26, 0x15, 0x00, 0x01, 0x00, 0x32, 0x00, 0x64, 0x00, 0x6B, 0xA2,
        0x80, 0x51, 0x16, 0x00, 0x01, 0x00, 0x32, 0x00, 0x64, 0x00, 0x69, 0xAB, 0xCC, 0x6D, 0x17, 0x00,
        0x01, 0x00, 0x32, 0x00, 0x64, 0x00, 0x24, 0xD8, 0xB8, 0xBA, 0x18, 0x00, 0x01, 0x00, 0x32, 0x00,
        0x64, 0x00, 0x3D, 0x90, 0x78, 0xF7, 0x19, 0x00, 0x01, 0x00, 0x32, 0x00, 0x64, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xBE, 0x00, 0x88, 0x2F, 0x32, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x75, 0x8C,
        0x60, 0x07, 0x32, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0x3F, 0xE8, 0x04, 0x32, 0x00,
        0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x74, 0x22, 0x78, 0x32, 0x32, 0x00, 0x64, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xDC, 0xC7, 0xDB, 0x29, 0x32, 0x00, 0x64, 0x00, 0x57, 0xCA, 0xBC, 0x26, 0x1F, 0x00,
        0x01, 0x00, 0x32, 0x00, 0x64, 0x00, 0x6B, 0xA2, 0x80, 0x51, 0x20, 0x00, 0x01, 0x00, 0x32, 0x00,
        0x64, 0x00, 0x69, 0xAB, 0xCC, 0x6D, 0x21, 0x00, 0x01, 0x00, 0x32, 0x00, 0x64, 0x00, 0x24, 0xD8,
        0xB8, 0xBA, 0x22, 0x00, 0x01, 0x00, 0x32, 0x00, 0x64, 0x00, 0x3D, 0x90, 0x78, 0xF7, 0x23, 0x00,
        0x01, 0x00, 0x32, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1D, 0x3E, 0xDE, 0x26, 0x32, 0x00,
        0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF1, 0x6E, 0x6F, 0x38, 0x32, 0x00, 0x64, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x6F, 0x34, 0x8A, 0x27, 0x32, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF1, 0x0E,
        0x9C, 0x32, 0x32, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x96, 0x83, 0x05, 0x32, 0x00,
        0x64, 0x00, 0x57, 0xCA, 0xBC, 0x26, 0x29, 0x00, 0x01, 0x00, 0x32, 0x00, 0x64, 0x00, 0x6B, 0xA2,
        0x80, 0x51, 0x2A, 0x00, 0x01, 0x00, 0x32, 0x00, 0x64, 0x00, 0x69, 0xAB, 0xCC, 0x6D, 0x2B, 0x00,
        0x01, 0x00, 0x32, 0x00, 0x64, 0x00, 0x24, 0xD8, 0xB8, 0xBA, 0x2C, 0x00, 0x01, 0x00, 0x32, 0x00,
        0x64, 0x00, 0x3D, 0x90, 0x78, 0xF7, 0x2D, 0x00, 0x01, 0x00, 0x32, 0x00, 0x64, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xCE, 0x56, 0x26, 0x02, 0x32, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x97,
        0xA1, 0x3A, 0x32, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x92, 0x73, 0xDE, 0x29, 0x32, 0x00,
        0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x4E, 0x00, 0x1D, 0x32, 0x00, 0x64, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x40, 0x9B, 0x99, 0x1A, 0x32, 0x00, 0x64, 0x00, 0x57, 0xCA, 0xBC, 0x26, 0x33, 0x00,
        0x01, 0x00, 0x32, 0x00, 0x64, 0x00, 0x6B, 0xA2, 0x80, 0x51, 0x34, 0x00, 0x01, 0x00, 0x32, 0x00,
        0x64, 0x00, 0x69, 0xAB, 0xCC, 0x6D, 0x35, 0x00, 0x01, 0x00, 0x32, 0x00, 0x64, 0x00, 0x24, 0xD8,
        0xB8, 0xBA, 0x36, 0x00, 0x01, 0x00, 0x32, 0x00, 0x64, 0x00, 0x3D, 0x90, 0x78, 0xF7, 0x37, 0x00,
        0x01, 0x00, 0x32, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0xA7, 0xAC, 0x22, 0x32, 0x00,
        0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6C, 0x0D, 0xAD, 0x0E, 0x32, 0x00, 0x64, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xB2, 0xEE, 0x03, 0x0E, 0x32, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0xCD,
        0x84, 0x2D, 0x32, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x5F, 0x9F, 0x14, 0x32, 0x00,
        0x64, 0x00, 0x00, 0x00 
    ];

    fs::write("./original.tree", &buffer).unwrap();

    let mut object = HIRCObject::from_bytes((&buffer, 0)).unwrap().1;
    println!("Old object: {:#?}", object);

    object.update().unwrap();
    let new_buffer = object.to_bytes().unwrap();
    fs::write("./new.tree", &new_buffer).unwrap();

    let mut new_object = HIRCObject::from_bytes((&buffer, 0)).unwrap().1;
    println!("New object: {:#?}", new_object);
    // assert_eq!(buffer.as_slice(), new_buffer.as_slice());
    // assert_eq!(object, new_object);
}


fn dissect_bnk(data: &mut (impl io::Read + io::Seek)) -> Result<(), io::Error> {
    let mut header_bytes = vec![0u8; 8];
    while data.read_exact(&mut header_bytes).is_ok() {
        let header = {
            let result = SectionHeader::from_bytes((header_bytes.as_slice(), 0))
                .expect("Could not parse header bytes");

            result.1
        };

        //println!("Discovered bnk section. magic = {}", String::from_utf8((&header.magic).to_vec()).unwrap());

        if &header.magic == b"HIRC" {
            // Read HIRC object count
            let count = {
                let mut count_buffer = vec![0u8; 4];
                data.read_exact(&mut count_buffer)?;
                let count_buffer: [u8; 4] = count_buffer.as_slice()[0..4].try_into().unwrap();
                u32::from_le_bytes(count_buffer)
            };

            for _ in 0..count {
                let (object_type, object_size, object_id)= {
                    let mut buffer = vec![0u8; 9];
                    data.read_exact(&mut buffer)?;

                    let type_buffer: [u8; 1] = buffer.as_slice()[0..1].try_into().unwrap();
                    let size_buffer: [u8; 4] = buffer.as_slice()[1..5].try_into().unwrap();
                    let id_buffer: [u8; 4] = buffer.as_slice()[5..9].try_into().unwrap();

                    let object_type = u8::from_le_bytes(type_buffer);
                    let object_size = u32::from_le_bytes(size_buffer);
                    let object_id = u32::from_le_bytes(id_buffer);

                    (object_type, object_size, object_id)
                };

                println!("Parsing HIRC object. type = {}, size = {}, id = {}", object_type, object_size, object_id);

                // Seek back to beginning of object
                data.seek(io::SeekFrom::Current(-9))?;

                // Buffer entire object the size indicated by the HIRC object in including
                // the object ID. There we only need to account for the type (byte) and 
                // size field (u32).
                let mut buffer = vec![0u8; (object_size + 5) as usize];
                data.read_exact(&mut buffer)?;

                // Attempt to parse object
                let (rest, object) = HIRCObject::from_bytes((buffer.as_slice(), 0))
                    .expect("Failed parsing object");

                match object.body {
                    wwise_format::HIRCObjectBody::DialogueEvent(o) => debug_print_tree(o),
                    _ => {},
                }

                // println!("Parsed HIRC object: {:#?}", object);

                if !rest.0.is_empty() {
                    panic!("{} bytes left in buffer", rest.0.len());
                }
            }

            return Ok(());
        } else {
            data.seek(io::SeekFrom::Current(header.size as i64))?;
        }
    }

    Ok(())
}

fn debug_print_tree(o: wwise_format::CAkDialogueEvent) {
    println!("-----------------");
    //let mut nodes = vec![];

    // let mut layers = vec![];
    let mut current_layer = o.tree;
    while !current_layer.is_empty() {
        let mut next_layer = vec![]; 
        for node in current_layer.iter() {
            for child in node.children.iter() {
                if child.key == 0 {
                    println!("\"{}-{}\" -> \"{}-{} (default match)\";", node.key, node.index, node.key, node.index);
                } else {
                    println!("\"{}-{}\" -> \"{}-{}\";", node.key, node.index, child.key, child.index);
                }

                next_layer.push(child.clone());
            }
        }

        current_layer = next_layer;
    }

    println!("Measured depth");

    // for _ in 0..o.arguments.len() {
    //
    //     let mut current_layer_children = vec![];
    //     for node in current_layer.iter() {
    //         for child in node.children.iter() {
    //             // Default case
    //             if child.key == 0 && child.node_id != 0 {
    //                 println!("\"{}\" -> \"{} Default\";", node.key, node.key);
    //             } else {
    //                 println!("\"{}\" -> \"{}\";", node.key, child.key);
    //             }
    //
    //             current_layer_children.push(child.clone());
    //         }
    //     }
    //
    //     println!("Got {} children in layer", current_layer_children.len());
    //
    //     layers.push(current_layer.clone());
    //     current_layer = current_layer_children;
    // }
    //
    /*
    for node in nodes {
        println!("{} {}", node.node_id, node.key);
    }
    */
}

#[derive(Debug, DekuRead, DekuWrite)]
struct SectionHeader {
    magic: [u8; 4],
    size: u32,
}
